#!/usr/bin/perl -w

use strict;
use warnings;
use Getopt::Long;
use Pod::Usage;
use File::Basename;
use IO::Handle;
use Time::HiRes("usleep");
use Socket;
use FileHandle;
use IPC::Open2;

# always flush
$| = 1;

# Get configuration
$CFG::builddir = $ENV{'HOME'}."/devel/nul/build";
$CFG::hypervisor = "bin/apps/hypervisor";
$CFG::server = "os.inf.tu-dresden.de:boot/novaboot/\$NAME";
$CFG::server_grub_prefix = "(nd)/tftpboot/sojka/novaboot/\$NAME";
$CFG::grub_keys = "/novaboot\n\n/\$NAME\n\n";
$CFG::genisoimage = "genisoimage";
$CFG::iprelay_addr = '141.76.48.252';
$CFG::qemu = 'qemu';
$CFG::script_modifier = '';

my $qemu_flags = "-cpu coreduo -smp 2";

sub read_config($) {
    my ($cfg) = @_;
    {
	package CFG; # Put config data into a separate namespace
	my $rc = do($cfg);

	# Check for errors
	if ($@) {
	    die("ERROR: Failure compiling '$cfg' - $@");
	} elsif (! defined($rc)) {
	    die("ERROR: Failure reading '$cfg' - $!");
	} elsif (! $rc) {
	    die("ERROR: Failure processing '$cfg'");
	}
    }
}

my $cfg = $ENV{'NOVABOOT_CONFIG'};
if (! $cfg or ! -s $cfg) { $cfg = $ENV{'HOME'}."/.novaboot"; }
if (-s $cfg) { read_config($cfg); }

$CFG::iprelay_addr = $ENV{'NOVABOOT_IPRELAY'} if $ENV{'NOVABOOT_IPRELAY'};

# Command line
my ($append, $bender, $builddir, $config_name_opt, $dhcp_tftp, $dump_config, $grub_config, $help, $I_opt, $iprelay, $iso_image, $man, $off_opt, $on_opt, $qemu, $qemu_flags_cmd, $serial, $server);

Getopt::Long::Configure("no_ignore_case");
GetOptions (
    "append|a=s"     => \$append,
    "bender|b"       => \$bender,
    "build-dir=s"    => \$builddir,
    "config|c=s"     => sub { read_config($_[1]); },
    "dhcp-tftp|d"    => \$dhcp_tftp,
    "dump-config"    => \$dump_config,
    "grub|g:s" 	     => \$grub_config,
    "I"		     => \$I_opt,
    "iprelay:s"	     => \$iprelay,
    "iso|i:s" 	     => \$iso_image,
    "name=s"	     => \$config_name_opt,
    "off"	     => \$off_opt,
    "on"	     => \$on_opt,
    "qemu|Q=s" 	     => \$qemu,
    "qemu-flags|q=s" => \$qemu_flags_cmd,
    "serial|s:s"     => \$serial,
    "server:s" 	     => \$server,
    "h" 	     => \$help,
    "help" 	     => \$man,
    ) or pod2usage(2);
pod2usage(1) if $help;
pod2usage(-exitstatus => 0, -verbose => 2) if $man;

if (defined $config_name_opt && scalar(@ARGV) > 1) { die "You cannot use --name with multiple scripts"; }

if (defined $I_opt) { $server=''; $iprelay=''; }

if ($server) { $CFG::server = $server; }
if ($qemu) { $CFG::qemu = $qemu; }
if ($builddir) { $CFG::builddir = $builddir; }

if ($dump_config) {
    print
"\$builddir = '$CFG::builddir';
\$hypervisor = '$CFG::hypervisor';
\$server = '$CFG::server';
\$server_grub_prefix = '$CFG::server_grub_prefix';
\$grub_keys = '$CFG::grub_keys';
\$genisoimage = '$CFG::genisoimage';
\$iprelay_addr = '$CFG::iprelay_addr';
\$qemu = '$CFG::qemu';
\$script_modifier = '$CFG::script_modifier';
";
    exit;
}

if (defined $serial) {
    $serial ||= "/dev/ttyUSB0";
}

if (defined $grub_config) {
    $grub_config ||= "menu.lst";
}

if ($on_opt) { $iprelay="on"; }
if ($off_opt) { $iprelay="off"; }

my $IPRELAY;
if (defined $iprelay) {
    $CFG::iprelay_addr =~ /([.0-9]+)(:([0-9]+))?/;
    my $addr = $1;
    my $port = $3 || 23;
    my $paddr   = sockaddr_in($port, inet_aton($addr));
    my $proto   = getprotobyname('tcp');
    socket($IPRELAY, PF_INET, SOCK_STREAM, $proto)  || die "socket: $!";
    connect($IPRELAY, $paddr)    || die "connect: $!";
    $IPRELAY->autoflush(1);

    sub relaycmd($$) {
	my ($relay, $onoff) = @_;
	die unless ($relay == 1 || $relay == 2);

	my $cmd = ($relay == 1 ? 0x5 : 0x6) | ($onoff ? 0x20 : 0x10);
	return "\xFF\xFA\x2C\x32".chr($cmd)."\xFF\xF0";
    }
}

if ($iprelay && ($iprelay eq "on" || $iprelay eq "off")) {
    print $IPRELAY relaycmd(1, 1); # Press power button
    if ($iprelay eq "on") {
	usleep(200000);		# Short press
    } else {
	usleep(6000000);	# Long press to switch off
    }
    print $IPRELAY relaycmd(1, 0);
    exit;
}


# Parse the config(s)
my @scripts;
my $file;
my $line;
my $EOF;
my $last_fn = '';
my ($modules, $variables, $configs, $continuation);
while (<>) {
    if ($ARGV ne $last_fn) { # New script
	die "Missing EOF in $last_fn" if $file;
	die "Unfinished line in $last_fn" if $line;
	$last_fn = $ARGV;
	push @scripts, { 'filename' => $ARGV,
			 'modules' => $modules = [],
			 'variables' => $variables = {},
			 'configs' => $configs = {}};

    }
    chomp();
    next if /^#/ || /^\s*$/;	# Skip comments and empty lines
    if (/^([A-Z_]+)=(.*)$/) {	# Internal variable
	$$variables{$1} = $2;
	next;
    }
    if (/^([^ ]*)(.*?)[[:space:]]*<<([^ ]*)$/) { # Heredoc start
	push @$modules, "$1$2";
	$file = [];
	$$configs{$1} = $file;
	$EOF = $3;
	next;
    }
    if ($file && $_ eq $EOF) {	# Heredoc end
	undef $file;
	next;
    }
    if ($file) {		# Heredoc content
	push @{$file}, "$_\n";
	next;
    }
    $_ =~ s/^[[:space:]]*// if ($continuation);
    if (/\\$/) {		# Line continuation
	$line .= substr($_, 0, length($_)-1);
	$continuation = 1;
	next;
    }
    $continuation = 0;
    $line .= $_;
    $line .= " $append" if ($append && scalar(@$modules) == 0);
    {
	$_ = $line;
	eval $CFG::script_modifier;
	$line = $_;
    }
    push @$modules, $line;
    $line = '';
}
#use Data::Dumper;
#print Dumper(\@scripts);

sub generate_configs($$) {
    my ($base, $configs) = @_;
    if ($base) { $base = "$base/"; };
    foreach my $fn(keys %$configs) {
	my $config = $$configs{$fn};
	open(my $f, '>', $fn);
	map { s|^rom://(.*)|rom://$base$1|; print $f "$_"; } @{$config};
	close($f);
    }
}

sub generate_grub_config($$$$;$)
{
    my ($filename, $title, $base, $modules_ref, $prepend) = @_;
    if ($base) { $base = "$base/"; };
    open(my $fg, '>', $filename) or die "$filename: $!";
    print $fg "$prepend\n" if $prepend;
    my $endmark = ($serial || defined $iprelay) ? ';' : '';
    print $fg "title $title$endmark\n" if $title;
    #print $fg "root $base\n"; # root doesn't really work for (nd)
    my $first = 1;
    foreach (@$modules_ref) {
	if ($first) {
	    $first = 0;
	    my ($kbin, $kcmd) = split(' ', $_, 2);
	    $kcmd = '' if !defined $kcmd;
	    print $fg "kernel ${base}$kbin $kcmd\n";
	} else {
	    s|rom://([^ ]*)|rom://$base$1|; # Translate rom:// files - needed for vdisk parameter of sigma0
	    print $fg "module $base$_\n";
	}
    }
    close($fg);
}

sub exec_verbose($)
{
    my $cmd = shift;
    print "Running: $cmd\n";
    exec($cmd);
}

sub system_verbose($)
{
    my $cmd = shift;
    print "Running: $cmd\n";
    system($cmd);
}


chdir($CFG::builddir) or die "Can't change directory to $CFG::builddir: $!\nPlease update your configuration in $cfg\n";
print "novaboot: Entering directory `$CFG::builddir'\n";

my (%files_iso, $menu_iso, $config_name, $filename);

foreach my $script (@scripts) {
    $filename = $$script{filename};
    $modules = $$script{modules};
    $configs = $$script{configs};
    $variables = $$script{variables};
    my ($server_grub_prefix);
    
    if (defined $config_name_opt) {
	$config_name = $config_name_opt;
    } else {
	($config_name = $filename) =~ s#.*/##;
    }

    @$modules = ($CFG::hypervisor . " " . ($variables->{HYPERVISOR_PARAMS} || "serial spinner"), @$modules);
    @$modules = ("bin/boot/bender", @$modules) if ($bender || defined $ENV{'NOVABOOT_BENDER'});

    if (defined $grub_config) {
	generate_configs("", $configs);
	generate_grub_config($grub_config, $config_name, "", $modules);
	print("GRUB menu created: $CFG::builddir/$grub_config\n");
	exit;
    }

    if (defined $server) {
	($server_grub_prefix = $CFG::server_grub_prefix) =~ s/\$NAME/$config_name/;
	($server = $CFG::server)			 =~ s/\$NAME/$config_name/;
	generate_configs($server_grub_prefix, $configs);
	my $grub_config ||= "menu.lst";
	generate_grub_config($grub_config, $config_name, $server_grub_prefix, $modules,
			     $server_grub_prefix eq $CFG::server_grub_prefix ? "timeout 0" : undef);
	my ($hostname, $path) = split(":", $server, 2);
	my $files = "$grub_config " . join(" ", map({ ($file) = m/([^ ]*)/; $file; } @$modules));
	my $combined_menu_lst = ($CFG::server =~ m|/\$NAME$|);
	system_verbose("tar czhf - $files | ssh $hostname 'mkdir -p $path; cd $path; tar xzpf -" .
		       ($combined_menu_lst ? "; cd ..; cat */menu.lst > menu.lst'" : "'"));
    }
    
    if (defined $iso_image) {
	generate_configs("(cd)", $configs);
	my $menu;
	generate_grub_config(\$menu, $config_name, "(cd)", $modules);
	$menu_iso .= "$menu\n";
	map { ($file,undef) = split; $files_iso{$file} = 1; } @$modules;
    }
}

if (defined $iso_image) {
    open(my $fh, ">menu-iso.lst");
    print $fh "timeout 5\n\n$menu_iso";
    close($fh);
    my $files = "boot/grub/menu.lst=menu-iso.lst " . join(" ", map("$_=$_", keys(%files_iso)));
    $iso_image ||= "$config_name.iso";
    my $ret = system_verbose("$CFG::genisoimage -R -b stage2_eltorito -no-emul-boot -boot-load-size 4 -boot-info-table -hide-rr-moved -J -joliet-long -o $iso_image -graft-points bin/boot/grub/ $files");
    if ($ret >> 8) { die("The above command failed!"); }
    print("ISO image created: $CFG::builddir/$iso_image\n");
}

######################################################################
# Boot NOVA using various methods and send serial output to stdout
######################################################################

if (scalar(@scripts) > 1 && ( defined $dhcp_tftp || defined $serial || defined $iprelay)) {
    die "You cannot do this with multiple scripts simultaneously";
}

if ($variables->{WVDESC}) {
    print "Testing \"$variables->{WVDESC}\" in $filename:\n";
} elsif ($filename =~ /\.wv$/) {
    print "Testing \"all\" in $filename:\n";
}

if (!(defined $dhcp_tftp || defined $serial || defined $iprelay || defined $server)) {
    # Qemu
    $qemu_flags = $variables->{QEMU_FLAGS} if $variables->{QEMU_FLAGS};
    $qemu_flags = $qemu_flags_cmd if $qemu_flags_cmd;

    if (defined $iso_image) {
	# Boot NOVA with grub (and test the iso image)
	$qemu_flags .= " -cdrom $config_name.iso";
    } else {
	# Boot NOVA without GRUB

	# Non-patched qemu doesn't like commas, but NUL can live with pluses instead of commans
	foreach (@$modules) {s/,/+/g;}
	generate_configs("", $configs);

	my ($kbin, $kcmd) = split(' ', shift(@$modules), 2);
	$kcmd = '' if !defined $kcmd;
	my $initrd = join ",", @$modules;

	$qemu_flags .= " -kernel $kbin -append '$kcmd' -initrd \"$initrd\""
    }
    $qemu_flags .= " -serial stdio"; # Redirect serial output (for collecting test restuls)
    exec_verbose("$CFG::qemu -name '$config_name' $qemu_flags");
}

my ($dhcpd_pid, $tftpd_pid);

if (defined $dhcp_tftp)
{
    generate_configs("(nd)", $configs);
    system('mkdir -p tftpboot');
    generate_grub_config("tftpboot/os-menu.lst", $config_name, "(nd)", \@$modules, "timeout 0");
    open(my $fh, '>', 'dhcpd.conf');
    print $fh 'subnet 10.23.23.0 netmask 255.255.255.0 {
		      range 10.23.23.10 10.23.23.10;
		      filename "bin/boot/grub/pxegrub.pxe";
		      next-server 10.23.23.1;}';
    close($fh);
    system("ip a add 10.23.23.1/24 dev eth0;
	    ip l set dev eth0 up;
	    touch dhcpd.leases");

    $dhcpd_pid = fork();
    if ($dhcpd_pid == 0) {
	# This way, the spawned server are killed when this script is killed.
	exec_verbose("dhcpd -d -cf dhcpd.conf -lf dhcpd.leases -pf dhcpd.pid");
    }
    $tftpd_pid = fork();
    if ($tftpd_pid == 0) {
	exec_verbose("in.tftpd --foreground --secure -v -v -v $CFG::builddir");
    }
    $SIG{TERM} = sub { print "CHILDS KILLED\n"; kill 15, $dhcpd_pid, $tftpd_pid; };
}

if ($serial || defined $iprelay) {
    my $CONN;
    if (defined $iprelay) {
	print $IPRELAY relaycmd(2, 1); # Reset the machine
	usleep(200000);
	print $IPRELAY relaycmd(2, 0);

	$CONN = $IPRELAY;
    } elsif ($serial) {
	system("stty -F $serial raw -crtscts -onlcr 115200");
	open($CONN, "+<", $serial) || die "open $serial: $!";
	$CONN->autoflush(1);
    }
    if (!defined $dhcp_tftp && $CFG::grub_keys) {
	# Control grub via serial line
	while (<$CONN>) {
	    if (/Press any key to continue/) { print $CONN "\n"; last; }
	}
	$CFG::grub_keys =~ s/\$NAME/$config_name;/;
	my @characters = split(//, $CFG::grub_keys);
	foreach (@characters) {
	    print $CONN $_;
	    usleep($_ eq "\n" ? 100000 : 10000);
	}
	print $CONN "\n";
    }
    # Pass the NOVA output to stdout.
    while (<$CONN>) {
	print;
    }
    kill 15, $dhcpd_pid, $tftpd_pid if ($dhcp_tftp);
    exit;
}

if (defined $dhcp_tftp) {
    my $pid = wait();
    if ($pid == $dhcpd_pid) { print "dhcpd exited!\n"; }
    elsif ($pid == $tftpd_pid) { print "tftpd exited!\n"; }
    else { print "wait returned: $pid\n"; }
}

=head1 NAME

novaboot - NOVA boot script interpreter

=head1 SYNOPSIS

B<novaboot> [--help] [--append=...] [--bender] [--config=<file>]
[--dhcp-tftp] [--dump-config] [--grub] [--iprelay] [--iso]
[--qemu=...] [--qemu-flags=<flags>] [--serial] [--server] [--] script...

=head1 DESCRIPTION

This program boots the NOVA system either in qemu or on a real
hardware. Its operation is controlled by a script which determines
which binaries to load and their parameters. See below for the syntax.

If it is possible, the program also redirects the serial output of the
booted system to stdout.

Besides that, this program can also create bootable ISO images based
on one or more scripts.

Typical use cases are:

=over 8

=item ./script

Boots NOVA system described in I<script> (which is made executable and
starts with #!/usr/bin/env novaboot) in B<qemu>.

=item ./script --server --iprelay

Copy files to a PXE server and uses TCP/IP-controlled relay to reset
the test machine and receive its serial output.

=item sudo ./script --dhcp-tftp

Starts local DHCP and TFTP server to boot the configuration described
in I<script>. The test machine is supposed to be connected via direct
Ethernet connection to the local machine.

=item novaboot script1 script2 --iso

Creates bootable ISO image with configurations I<script1> and
I<script2> in GRUB's menu.

=back

=head1 OPTIONS

=over 8

=item -a, --append=<parameters>

Appends a string to the root task's command line.

=item -b, --bender

Boot bender tool to find serial ports.

=item --build-dir=<directory>

Overrides build directory location from the configuration file.

=item -c, --config=<filename>

Use a different config than the default one (i.e. ~/.novaboot).

=item -d, --dhcp-tftp

Turns your workstation into a DHCP and TFTP server so that NOVA
can be booted via PXE BIOS on a test machine directly connected by
a plain Ethernet cable to your workstation.

=item --dump-config

Dumps current configuration to stdout end exits. Useful as an
initial template for a config file.

=item -g, --grub[=<filename>]

Generate grub menu file. If the file name is not specified,
menu.lst is used. The file name is relative to NUL build
directory.

=item -h, --help

Print short (-h) or long (--help) help.

=item -I

Shortcut for --server --iprelay.

=item --iprelay[=cmd]

If not I<cmd> is given, use IP relay to reset the machine and to get
the serial output. The IP address of the relay is determined by
$iprelay_addr configuration variable.

If I<cmd> is one of "on" or "off", the IP relay is used press power
button for a short (in case of "on") or long (in case of "off") time.
The script then exits.

Note: This option is expected to work with HWG-ER02a IP relays.

=item -i, --iso[=filename]

Generate the ISO image that boots NOVA system via Grub. If no
filename is given, the image is stored under NAME.iso, where NAME
is the name of novaboot script (see also --name).

=item --on, --off

Synonym for --iprelay=on/off.

=item --name=<string>

Use the name <string> instead of the name of the novaboot script.
This name is used for things like a title of grub menu or for the
server directory where the boot files are copied to.

=item -Q, --qemu=<qemu-binary>

Use specific version of qemu binary. The default is 'qemu'.

=item -q, --qemu-flags=<flags>

Use other qemu flags than are the default, i.e. "-cpu coreduo -smp 2".

=item --server[=[user@]server:path]

Copy all files needed for booting to a server (implies -g). The
files will be copied to the directory `path'. If the `path'
contains string $NAME, it will be replaced with the name of the
novaboot script (see also --name).

Additionally, if $NAME is the last component of the `path', a file
named `path'/menu.lst (with $NAME removed from `path') will be
created on the server by concatenating all `path'/*/menu.lst (with
$NAME removed from `path') files found on the server.

=item -s, --serial[=device]

Use serial line to control grub bootloader and to get the serial
output of the machine. The default value is /dev/ttyUSB0.

=back

=head1 NOVA BOOT SCRIPT SYNTAX

The syntax tries to mimic POSIX shell syntax. All file names in the
script are relative to the NUL build directory (see below).

Lines starting with "#" are ignored.

Lines that end with "\" are concatenated with the following line after
removal of the final "\" and leading whitespace of the following line.

Lines matching '^[A-Z_]+=' regexp assign values to internal variables.
See VARIABLES section.

Otherwise, first word on a line represents the filename of the module
to load, the remaining words are its command line parameters.

When the line ends with "<<WORD" then the subsequent lines until the
line containing only WORD are copied literally to the file named on
that line.

Example:
  #!/usr/bin/env novaboot
  WVDESC=Example program
  bin/apps/sigma0.nul S0_DEFAULT script_start:1,1 \
    verbose hostkeyb:0,0x60,1,12,2
  bin/apps/hello.nul
  hello.nulconfig <<EOF
  sigma0::mem:16 name::/s0/log name::/s0/timer name::/s0/fs/rom ||
  rom://bin/apps/hello.nul
  EOF

This example will load three modules: sigma0.nul, hello.nul and
hello.nulconfig. sigma0 gets some command line parameters and
hello.nulconfig file is generated on the fly from the lines between
<<EOF and EOF.

=head2 VARIABLES

The following variables are interpreted in the novaboot script:

=over 8

=item WVDESC

Description of the wvtest-compliant program.

=item QEMU_FLAGS

Use specific qemu flags (can be overriden by -q).

=item HYPERVISOR_PARAMS

Parameters passed to hypervisor. The default is "serial spinner".

=back

=head1 CONFIGURATION FILE

novaboot can read its configuration from ~/.novaboot (or another file
specified with -c parameter). It is a file with perl syntax, which
sets values to certain variables. The current configuration can be
dumped with --dump-config switch. Use

    novaboot --dump-config > ~/.novaboot

to create a default config file and modify if to your needs. Some
configuration variables can be overriden by environment variables (see
below).

=head1 ENVIRONMENT VARIABLES

Some options can be specified not only via config file or command line
but also through environment variables. Environment overrides the
configuration file and command line parameters override the
environment.

=over 8

=item NOVABOOT_CONFIG

A name of default novaboot configuration file.

=item NOVABOOT_BENDER

Defining this variable has the same meaning as --bender option.

=item NOVABOOT_IPRELAY

The IP address (and optionaly the port) to connecto to the IP relay.
This overrides $iprelay_addr from the configuration file.

=back
