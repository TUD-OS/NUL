--- libvirt-0.9.6/configure.ac	2011-09-22 08:42:11.000000000 +0200
+++ libvirt-0.9.6-own/configure.ac	2011-10-12 10:12:02.000000000 +0200
@@ -309,6 +309,8 @@
   AC_HELP_STRING([--with-remote], [add remote driver support @<:@default=yes@:>@]),[],[with_remote=yes])
 AC_ARG_WITH([libvirtd],
   AC_HELP_STRING([--with-libvirtd], [add libvirtd support @<:@default=yes@:>@]),[],[with_libvirtd=yes])
+AC_ARG_WITH([nova],
+  AC_HELP_STRING([--with-nova], [add Nova support @<:@default=check@:>@]),[],[with_nova=yes])
 
 dnl
 dnl in case someone want to build static binaries
@@ -494,6 +496,11 @@
 fi
 AM_CONDITIONAL([WITH_TEST], [test "$with_test" = "yes"])
 
+if test "$with_nova" = "yes" ; then
+    AC_DEFINE_UNQUOTED([WITH_NOVA], 1, [whether NOVA driver is enabled])
+fi
+AM_CONDITIONAL([WITH_NOVA], [test "$with_nova" = "yes"])
+
 if test "$with_remote" = "yes" ; then
     AC_DEFINE_UNQUOTED([WITH_REMOTE], 1, [whether Remote driver is enabled])
 fi
@@ -2511,6 +2518,7 @@
 AC_MSG_NOTICE([     LXC: $with_lxc])
 AC_MSG_NOTICE([    PHYP: $with_phyp])
 AC_MSG_NOTICE([     ESX: $with_esx])
+AC_MSG_NOTICE([    NOVA: $with_nova])
 AC_MSG_NOTICE([ Hyper-V: $with_hyperv])
 AC_MSG_NOTICE([    Test: $with_test])
 AC_MSG_NOTICE([  Remote: $with_remote])
--- libvirt-0.9.6/src/Makefile.am	2011-09-20 05:18:54.000000000 +0200
+++ libvirt-0.9.6-own/src/Makefile.am	2011-10-12 10:12:02.000000000 +0200
@@ -310,6 +310,9 @@
 		lxc/lxc_controller.c				\
 		lxc/veth.c lxc/veth.h
 
+NOVA_DRIVER_SOURCES =						\
+		nova/nova_driver.c nova/nova_driver.h
+
 SECURITY_DRIVER_APPARMOR_HELPER_SOURCES =			\
 		security/virt-aa-helper.c
 
@@ -596,6 +599,21 @@
 libvirt_driver_test_la_SOURCES = $(TEST_DRIVER_SOURCES)
 endif
 
+if WITH_NOVA
+if WITH_DRIVER_MODULES
+mod_LTLIBRARIES += libvirt_driver_nova.la
+else
+noinst_LTLIBRARIES += libvirt_driver_nova.la
+libvirt_la_BUILT_LIBADD += libvirt_driver_nova.la
+endif
+libvirt_driver_nova_la_CFLAGS = \
+		-I@top_srcdir@/src/conf $(AM_CFLAGS)
+if WITH_DRIVER_MODULES
+libvirt_driver_nova_la_LDFLAGS = -module -avoid-version $(AM_LDFLAGS)
+endif
+libvirt_driver_nova_la_SOURCES = $(NOVA_DRIVER_SOURCES)
+endif
+
 if WITH_REMOTE
 if WITH_DRIVER_MODULES
 mod_LTLIBRARIES += libvirt_driver_remote.la
@@ -1084,6 +1102,7 @@
 		$(LIBXL_DRIVER_SOURCES)			\
 		$(ESX_DRIVER_SOURCES)				\
 		$(ESX_DRIVER_EXTRA_DIST)			\
+ 		$(NOVA_DRIVER_SOURCES)				\
 		$(HYPERV_DRIVER_SOURCES)			\
 		$(HYPERV_DRIVER_EXTRA_DIST)			\
 		$(NETWORK_DRIVER_SOURCES)			\
@@ -1483,6 +1502,10 @@
 	$(MKDIR_P) "$(DESTDIR)$(localstatedir)/run/libvirt/libxl"
 	$(MKDIR_P) "$(DESTDIR)$(localstatedir)/log/libvirt/libxl"
 endif
+if WITH_NOVA
+	$(MKDIR_P) "$(DESTDIR)$(localstatedir)/lib/libvirt/nova"
+	$(MKDIR_P) "$(DESTDIR)$(localstatedir)/run/libvirt/nova"
+endif
 if WITH_UML
 	$(MKDIR_P) "$(DESTDIR)$(localstatedir)/lib/libvirt/uml"
 	$(MKDIR_P) "$(DESTDIR)$(localstatedir)/run/libvirt/uml"
@@ -1528,6 +1551,10 @@
 	rmdir "$(DESTDIR)$(localstatedir)/run/libvirt/libxl" ||:
 	rmdir "$(DESTDIR)$(localstatedir)/log/libvirt/libxl" ||:
 endif
+if WITH_NOVA
+	rmdir "$(DESTDIR)$(localstatedir)/lib/libvirt/nova" ||:
+	rmdir "$(DESTDIR)$(localstatedir)/run/libvirt/nova" ||:
+endif
 if WITH_UML
 	rmdir "$(DESTDIR)$(localstatedir)/lib/libvirt/uml" ||:
 	rmdir "$(DESTDIR)$(localstatedir)/run/libvirt/uml" ||:
--- libvirt-0.9.6/src/driver.h	2011-09-16 15:09:43.000000000 +0200
+++ libvirt-0.9.6-own/src/driver.h	2011-10-12 10:12:02.000000000 +0200
@@ -30,6 +30,7 @@
     VIR_DRV_VMWARE = 13,
     VIR_DRV_LIBXL = 14,
     VIR_DRV_HYPERV = 15,
+    VIR_DRV_NOVA
 } virDrvNo;
 
 
--- libvirt-0.9.6/src/libvirt.c	2011-09-22 05:37:44.000000000 +0200
+++ libvirt-0.9.6-own/src/libvirt.c	2011-10-12 10:30:52.000000000 +0200
@@ -73,6 +73,9 @@
 # ifdef WITH_XENAPI
 #  include "xenapi/xenapi_driver.h"
 # endif
+# ifdef WITH_NOVA
+#  include "nova/nova_driver.h"
+# endif
 #endif
 
 #define VIR_FROM_THIS VIR_FROM_NONE
@@ -417,7 +420,9 @@
 
     virLogSetFromEnv();
 
+#if WITH_REMOTE
     virNetTLSInit();
+#endif
 
     VIR_DEBUG("register drivers");
 
@@ -462,6 +467,9 @@
 # ifdef WITH_XENAPI
     virDriverLoadModule("xenapi");
 # endif
+# ifdef WITH_NOVA
+    virDriverLoadModule("nova");
+#endif
 # ifdef WITH_REMOTE
     virDriverLoadModule("remote");
 # endif
@@ -493,6 +501,9 @@
 # ifdef WITH_XENAPI
     if (xenapiRegister() == -1) return -1;
 # endif
+# ifdef WITH_NOVA
+    if (novaRegister () == -1) return -1;
+# endif
 # ifdef WITH_REMOTE
     if (remoteRegister () == -1) return -1;
 # endif
--- libvirt-0.9.6/src/conf/domain_event.c	2011-08-25 11:43:44.000000000 +0200
+++ libvirt-0.9.6-own/src/conf/domain_event.c	2011-10-12 10:12:02.000000000 +0200
@@ -366,6 +366,7 @@
     for (i = 0 ; i < cbList->count ; i++) {
         if (cbList->callbacks[i]->cb == VIR_DOMAIN_EVENT_CALLBACK(callback) &&
             cbList->callbacks[i]->eventID == VIR_DOMAIN_EVENT_ID_LIFECYCLE &&
+            (!cbList->callbacks[i]->dom || !dom || memcmp(dom->uuid, cbList->callbacks[i]->dom->uuid, VIR_UUID_BUFLEN) == 0) &&
             cbList->callbacks[i]->conn == conn) {
             eventReportError(VIR_ERR_INTERNAL_ERROR, "%s",
                              _("event callback already tracked"));
--- libvirt-0.9.6/src/conf/domain_conf.c	2011-09-22 08:37:59.000000000 +0200
+++ libvirt-0.9.6-own/src/conf/domain_conf.c	2011-10-12 10:12:02.000000000 +0200
@@ -86,7 +86,8 @@
               "hyperv",
               "vbox",
               "one",
-              "phyp")
+              "phyp",
+              "nova")
 
 VIR_ENUM_IMPL(virDomainBoot, VIR_DOMAIN_BOOT_LAST,
               "fd",
--- libvirt-0.9.6/src/conf/domain_conf.h	2011-09-06 10:34:44.000000000 +0200
+++ libvirt-0.9.6-own/src/conf/domain_conf.h	2011-10-12 10:12:02.000000000 +0200
@@ -59,6 +59,7 @@
     VIR_DOMAIN_VIRT_VBOX,
     VIR_DOMAIN_VIRT_ONE,
     VIR_DOMAIN_VIRT_PHYP,
+    VIR_DOMAIN_VIRT_NOVA,
 
     VIR_DOMAIN_VIRT_LAST,
 };
--- libvirt-0.9.6/examples/domain-events/events-c/event-test.c	2011-09-03 02:26:55.000000000 +0200
+++ libvirt-0.9.6-own/examples/domain-events/events-c/event-test.c	2011-10-12 10:12:02.000000000 +0200
@@ -162,9 +162,9 @@
                                   int detail,
                                   void *opaque ATTRIBUTE_UNUSED)
 {
-    printf("%s EVENT: Domain %s(%d) %s %s\n", __func__, virDomainGetName(dom),
+    printf("%s EVENT: Domain %s(%d) %s %s detail=%x\n", __func__, virDomainGetName(dom),
            virDomainGetID(dom), eventToString(event),
-           eventDetailToString(event, detail));
+           eventDetailToString(event, detail), detail);
     return 0;
 }
 
@@ -383,7 +383,7 @@
                                                     VIR_DOMAIN_EVENT_CALLBACK(myDomainEventControlErrorCallback),
                                                     strdup("callback control error"), myFreeFunc);
 
-    if ((callback1ret != -1) &&
+    if (//(callback1ret != -1) &&
         (callback2ret != -1) &&
         (callback3ret != -1) &&
         (callback4ret != -1) &&
diff -urN libvirt-0.9.6/src/nova/nova_conf.h libvirt-0.9.6-own/src/nova/nova_conf.h
--- libvirt-0.9.6/src/nova/nova_conf.h	1970-01-01 01:00:00.000000000 +0100
+++ libvirt-0.9.6-own/src/nova/nova_conf.h	2011-10-12 10:12:02.000000000 +0200
@@ -0,0 +1,16 @@
+#ifndef __VIR_NOVA_CONF_H__
+# define __VIR_NOVA_CONF_H__
+
+# include "domain_event.h"
+
+struct nova_conn {
+  int sockfd;
+  int eventfd;
+  virDomainEventCallbackListPtr domainEventCallbacks;
+//  virDomainEventQueuePtr domainEventQueue;
+  virThreadPtr eventthread;
+  bool lock_init;
+  virMutex lock;
+};
+
+#endif /* __VIR_NOVA_CONF_H__ */
diff -urN libvirt-0.9.6/src/nova/nova_driver.c libvirt-0.9.6-own/src/nova/nova_driver.c
--- libvirt-0.9.6/src/nova/nova_driver.c	1970-01-01 01:00:00.000000000 +0100
+++ libvirt-0.9.6-own/src/nova/nova_driver.c	2011-10-12 10:21:18.000000000 +0200
@@ -0,0 +1,505 @@
+#include <sys/socket.h> //socket
+#include <arpa/inet.h> //inet_pton
+
+#include "virterror_internal.h"
+#include "datatypes.h"
+#include "nova_driver.h"
+#include "buf.h"
+#include "util.h"
+#include "uuid.h"
+#include "capabilities.h"
+#include "memory.h"
+#include "network_conf.h"
+#include "interface_conf.h"
+#include "domain_conf.h"
+#include "domain_event.h"
+#include "event.h"
+#include "storage_conf.h"
+#include "node_device_conf.h"
+#include "xml.h"
+#include "threads.h"
+#include "logging.h"
+
+#include "nova_types.h"
+#include "nova_conf.h"
+
+#include <fcntl.h>
+
+static void novaReadEvents(void *data) {
+  virConnectPtr nconn = (virConnectPtr)data;
+  struct nova_conn * conn = (struct nova_conn *)nconn->privateData;
+
+  unsigned char buf[NOVA_PACKET_LEN];
+  int res;
+
+  while(true) {
+    unsigned count = 0;
+    while(count < sizeof(buf)) {
+      res = read(conn->eventfd, buf + count, sizeof(buf) - count);
+      if (res == -1) return;
+      count += res;
+    }
+
+    struct outgoing_packet * in = (struct outgoing_packet *)buf;
+
+    if (in->version != ntohs(0xafff)) { printf("eventthread - version error %x != %x\n", ntohs(in->version), 0xafff); continue;}
+    if (in->opcode != ntohs(NOVA_EVENT)) { printf("eventthread - opcode error %x != %x\n", ntohs(in->opcode), NOVA_EVENT ); continue;}
+
+    uint32_t eventid      = *((uint32_t *)(&in->opspecific + 16));
+    uint32_t extra_len    = *((uint32_t *)(&in->opspecific + 16 + sizeof(uint32_t)));
+    unsigned char * extra = &in->opspecific + 16 + 2 * sizeof(uint32_t);
+    virDomainEventPtr event;
+
+    virDomainPtr dom = virDomainLookupByUUID(nconn, &in->opspecific);
+    if (dom) {
+      printf("got event %x %x\n", eventid, ntohl(eventid));
+      if (ntohl(eventid) == EVENT_REBOOT)
+        event = virDomainEventRebootNewFromDom(dom);
+      else
+        event = virDomainEventNewFromDom(dom, ntohl(eventid), ntohl(extra_len) == sizeof(uint32_t) ? *((uint32_t *)extra) : 0);
+    } else {
+      event = virDomainEventNew(-2, "hw", &in->opspecific, ntohl(eventid),
+        ntohl(extra_len) == sizeof(uint32_t) ? *((uint32_t *)extra) : 0);
+      printf("got hw event %p %x\n", event, ntohl(eventid));
+    }
+
+    if (!event) goto cleanup;
+//    if (virDomainEventQueuePush(conn->domainEventQueue, event) < 0) { virDomainEventFree(event); continue; }
+//    virDomainEventQueueDispatch(conn->domainEventQueue, conn->domainEventCallbacks, virDomainEventDispatchDefaultFunc, NULL);
+    virDomainEventDispatch(event, conn->domainEventCallbacks, virDomainEventDispatchDefaultFunc, NULL);
+
+    virDomainEventFree(event);
+
+    cleanup:
+    if (dom) virUnrefDomain(dom);
+  } 
+
+  return; 
+}
+
+static virDrvOpenStatus novaOpen(virConnectPtr conn,
+                    virConnectAuthPtr auth ATTRIBUTE_UNUSED,
+                    unsigned int flags ATTRIBUTE_UNUSED)
+{
+    int sockfd = 0, eventfd = 0;
+    struct nova_conn *nconn = 0;
+
+    if (!conn->uri)
+        return VIR_DRV_OPEN_DECLINED;
+
+    if (!conn->uri->scheme || STRNEQ(conn->uri->scheme, "nova"))
+        return VIR_DRV_OPEN_DECLINED;
+
+    if (!conn->uri->server || !conn->uri->port || conn->privateData)
+        return VIR_DRV_OPEN_DECLINED;
+
+    struct sockaddr_in addr;
+    addr.sin_family = AF_INET;
+    addr.sin_port = htons(conn->uri->port);
+    if (1 != inet_pton(AF_INET, conn->uri->server, &addr.sin_addr))
+      return VIR_DRV_OPEN_DECLINED;
+
+    sockfd = socket(AF_INET, SOCK_STREAM, 0);
+    if (sockfd < 0) goto error;
+    if (connect(sockfd, (struct sockaddr *)&addr, sizeof(addr))) goto error;
+
+    addr.sin_family = AF_INET;
+    addr.sin_port = htons(conn->uri->port + 1);
+    if (1 != inet_pton(AF_INET, conn->uri->server, &addr.sin_addr))
+      return VIR_DRV_OPEN_DECLINED;
+
+    eventfd = socket(AF_INET, SOCK_STREAM, 0);
+    if (eventfd < 0) goto error;
+    if (connect(eventfd, (struct sockaddr *)&addr, sizeof(addr))) goto error;
+
+    if (VIR_ALLOC(nconn) < 0) goto error;
+    memset(nconn, 0, sizeof(*nconn));
+    if (VIR_ALLOC(nconn->domainEventCallbacks) < 0) goto error;
+//    if (!(nconn->domainEventQueue = virDomainEventQueueNew())) goto error;
+
+    nconn->sockfd  = sockfd;
+    nconn->eventfd = eventfd;
+    conn->privateData = nconn;
+
+    if (VIR_ALLOC(nconn->eventthread) < 0) goto error; 
+    if (virMutexInit(&nconn->lock) < 0) goto error;
+    else nconn->lock_init = true;
+    if (virThreadCreate(nconn->eventthread, false, novaReadEvents, conn)) goto error;
+
+    return VIR_DRV_OPEN_SUCCESS;
+
+    error:
+    if (nconn && nconn->domainEventCallbacks) VIR_FREE(nconn->domainEventCallbacks);
+    if (nconn && nconn->eventthread) VIR_FREE(nconn->eventthread);
+    if (nconn && nconn->lock_init) virMutexDestroy(&nconn->lock);
+    if (nconn) VIR_FREE(nconn);
+    if (sockfd) close(sockfd);
+    if (eventfd) close(eventfd);
+
+    return VIR_DRV_OPEN_DECLINED;
+}
+
+static int novaClose(virConnectPtr conn)
+{
+    int res;
+    struct nova_conn *nconn;
+
+    if (!(nconn = conn->privateData)) return -1;
+    
+    res = close(nconn->sockfd);
+    res = close(nconn->eventfd);
+
+    if (nconn->domainEventCallbacks) VIR_FREE(nconn->domainEventCallbacks);
+//    if (nconn->domainEventQueue) virDomainEventQueueFree(nconn->domainEventQueue);
+    if (nconn->eventthread) {
+      virThreadJoin(nconn->eventthread);
+      VIR_FREE(nconn->eventthread);
+    }
+    if (nconn->lock_init) virMutexDestroy(&nconn->lock);
+    memset(nconn, 0, sizeof(*nconn));
+    VIR_FREE(nconn);
+    conn->privateData = 0;
+
+    printf("nova - %s - close connection to ...\n", res ? "failure" : "success");
+    return res;
+}
+
+#define create_nova_request(CONN, NOVAOPCODE, ERRORCODE, CODE) \
+  struct nova_conn *nconn = (CONN)->privateData; \
+  int sockfd = nconn->sockfd; \
+\
+  unsigned char buf[NOVA_PACKET_LEN]; \
+  struct incoming_packet * _out = (struct incoming_packet *)buf; \
+  ssize_t _res___; \
+\
+  _out->version = htons(0xafff); \
+  _out->opcode  = htons(NOVAOPCODE); \
+\
+  CODE \
+\
+  virMutexLock(&nconn->lock); \
+  unsigned ___count___ = 0; \
+  if (sizeof(buf) != write(sockfd, buf, sizeof(buf))) { _res___ = -1; goto request_abort; } \
+  while(___count___ < sizeof(buf)) { \
+    _res___ = read(sockfd, buf + ___count___, sizeof(buf) - ___count___); \
+    if (_res___ == -1) goto request_abort; \
+    ___count___ += _res___; \
+  } \
+  request_abort: \
+  virMutexUnlock(&nconn->lock); \
+  if (_res___ == -1) return ERRORCODE; \
+\
+  struct outgoing_packet * _in = (struct outgoing_packet *)buf; \
+\
+  if (_in->version != ntohs(0xafff)) { printf("version error\n"); return ERRORCODE; } \
+  if (_in->opcode != ntohs(NOVAOPCODE)) { printf("opcode error\n"); return ERRORCODE; } \
+  if (_in->result != NOVA_OP_SUCCEEDED) { return ERRORCODE; }
+
+static int nodeGetInfo(virConnectPtr conn, virNodeInfoPtr info) {
+  create_nova_request(conn, NOVA_HW_INFO, -1, {});
+
+  uint32_t * data = (uint32_t *)&_in->opspecific;
+  info->memory = ntohl(*data++); info->cpus = ntohl(*data++);
+  info->mhz = ntohl(*data++); info->nodes = ntohl(*data++);
+  info->sockets = ntohl(*data++); info->cores = ntohl(*data++);
+  info->threads = ntohl(*data++);
+  memcpy(info->model, data, 13);
+  return 0;
+}
+
+static int numOfDomains(virConnectPtr conn) {
+
+  create_nova_request(conn, NOVA_NUM_OF_ACTIVE_DOMAINS, -1, {});
+
+  uint32_t * num = (uint32_t *)&_in->opspecific;
+  uint32_t res = ntohl(*num);
+  return res;
+}
+
+static virDomainPtr domainCreateXML(virConnectPtr conn, const char *xml,
+                                      unsigned int flags)
+{
+  return 0;
+}
+
+static char *getCapabilities(virConnectPtr conn ATTRIBUTE_UNUSED) {
+  const char cap[] = \
+  "<host>" \
+   "<cpu>" \
+     "<arch>i686</arch" \
+   "</cpu>" \
+  "</host>" \
+  "<guest>" \
+   "<os_type>hvm</os_type>" \
+   "<arch name=""i686"">" \
+     "<wordsize>32</wordsize>" \
+   "</arch>" \
+   "<features/>" \
+  "</guest>";
+  char * tmp;
+  if (-1 == virAlloc(&tmp, sizeof(cap))) return 0;
+  else memcpy(tmp, cap, sizeof(cap));
+  return tmp;
+}
+
+static int listDomains (virConnectPtr conn,
+                            int *ids,
+                            int maxids)
+{
+  create_nova_request(conn, NOVA_LIST_ACTIVE_DOMAINS, -1, {});
+
+  unsigned i;
+  uint32_t * _ids  = (uint32_t *)&_in->opspecific;
+  uint32_t _maxids = ntohl(*_ids);
+
+  _ids++;
+
+  uint32_t max = _maxids < maxids ? _maxids : maxids;
+
+  for (i=0; i < max; i++) {
+    *ids = ntohl(*_ids);
+    ids++;
+    _ids++; 
+  }
+
+  return max;
+}
+
+static int numOfDefinedDomains(virConnectPtr conn) {
+  create_nova_request(conn, NOVA_NUM_OF_DEFINED_DOMAINS, -1, {});
+
+  uint32_t * num = (uint32_t *)&_in->opspecific;
+  uint32_t res = ntohl(*num);
+
+  return res;
+}
+
+static virDomainPtr domainLookupByUUID(virConnectPtr conn,
+                                       const unsigned char *uuid)
+{
+  create_nova_request(conn, NOVA_GET_NAME_UUID, NULL, 
+    {
+      memcpy(&_out->opspecific, uuid, VIR_UUID_BUFLEN);
+    });
+
+  buf[NOVA_PACKET_LEN - 1] = 0; //zero terminate for sure
+
+  uint32_t * _op = (uint32_t *)&_in->opspecific;
+  int id = ntohl(*_op);
+  char const * name = (char const *)(&_in->opspecific + sizeof(*_op));
+
+  virDomainPtr res = virGetDomain(conn, name, uuid);
+  if (res) res->id = id;
+
+  return res;
+}
+
+static virDomainPtr domainLookupByID(virConnectPtr conn, int id)
+{
+  create_nova_request(conn, NOVA_GET_NAME_ID, NULL, 
+    {
+      uint32_t * out_id = (uint32_t *)&_out->opspecific;
+      *out_id = htonl(id);
+    });
+
+  buf[NOVA_PACKET_LEN - 1] = 0; //zero terminate for sure
+  unsigned char const * uuid = (unsigned char const *)&_in->opspecific;
+  char const * name = (char const *)(&_in->opspecific + 16);
+
+  virDomainPtr res = virGetDomain(conn, name, uuid);
+  if (res) res->id = id;
+
+  return res;
+}
+
+static int domainCreate(virDomainPtr domain) {
+  create_nova_request(domain->conn, NOVA_VM_START, -1, {
+    unsigned char _uuid[VIR_UUID_BUFLEN];
+    if (-1 == virUUIDGenerate(_uuid)) return -1;
+
+    char * uuid = (char *)&_out->opspecific;
+    memcpy(uuid, domain->uuid, VIR_UUID_BUFLEN);
+    uuid += VIR_UUID_BUFLEN;
+    memcpy(uuid, _uuid, VIR_UUID_BUFLEN);
+  });
+
+  uint32_t * _op = (uint32_t *)&_in->opspecific;
+  int id = ntohl(*_op);
+
+  if (id) {
+    virDomainPtr res = domainLookupByID(domain->conn, id);
+    if (res) res->id = id;
+    else return -1;
+  }
+  return 0;
+}
+
+static int domainIsPersistent(virDomainPtr dom) {
+  if (!dom) return -1;
+
+  if (dom->id == -1) return 1; //XXX fix it - guessing
+  return 0;
+}
+
+static int domainEventRegisterAny(virConnectPtr conn, 
+  virDomainPtr dom, int eventID, virConnectDomainEventGenericCallback cb,
+  void * opaque, virFreeCallback freecb) //XXX currently no registry per event possible, all or nothing for all domains or just for a specific
+{
+  int res;
+
+  create_nova_request(conn, NOVA_ENABLE_EVENT, -1, 
+    {
+      uint32_t * out_id = (uint32_t *)&_out->opspecific;
+      if (dom)
+        *out_id = htonl(dom->id);
+      else
+        *out_id = htonl(-1);
+    });
+
+  res = virDomainEventCallbackListAddID(conn,
+                                        nconn->domainEventCallbacks,
+                                        dom, eventID,
+                                        cb, opaque, freecb);
+  return res;
+}
+
+static int domainEventDeregisterAny(virConnectPtr conn, int callbackID)
+{
+  create_nova_request(conn, NOVA_DISABLE_EVENT, -1,
+    {
+      uint32_t * out_id = (uint32_t *)&_out->opspecific;
+      *out_id = htonl(-1);
+    });
+ 
+  return virDomainEventCallbackListRemoveID(conn, nconn->domainEventCallbacks, callbackID);
+}
+
+static int listDefinedDomains(virConnectPtr conn, char ** const names, int maxnames)
+{
+  unsigned i;
+  char * out;
+
+  create_nova_request(conn, NOVA_LIST_DEFINED_DOMAINS, -1, {
+      uint32_t * max = (uint32_t *)&_out->opspecific;
+      *max = htonl(maxnames);
+    });
+
+  uint32_t * _num = (uint32_t *)&_in->opspecific;
+  uint32_t    num = ntohl(*_num);
+  char     * name = (char *)(&_in->opspecific + 4);
+
+  for (i=0; i < num; i++) {
+    uint32_t len   = strlen(name) + 1;
+  
+    if (-1 == virAlloc(&out, len)) return -1;
+    memcpy(out, name, len);
+    names[i] = out;
+    name += len;
+  }
+
+  return num;
+}
+
+static virDomainPtr domainLookupByName(virConnectPtr conn, const char * name)
+{
+  create_nova_request(conn, NOVA_GET_NAME, NULL,
+    {
+      if (strlen(name) + 1 > NOVA_PACKET_LEN - (&_out->opspecific - buf)) return NULL;
+      memcpy(&_out->opspecific, name, strlen(name) + 1);
+    });
+
+  unsigned char const * uuid = (unsigned char const *)&_in->opspecific;
+  char const * _name = (char const *)(&_in->opspecific + 16);
+
+  if (memcmp(name, _name, strlen(name) + 1)) return NULL;
+  virDomainPtr res = virGetDomain(conn, name, uuid);
+  if (res) res->id = -1;
+
+  return res;
+}
+
+static int domainDestroy (virDomainPtr domain)
+{
+  if (!domain || domain->id == -1) return -1;
+
+  create_nova_request(domain->conn, NOVA_VM_DESTROY, -1, {
+      uint32_t * out_id = (uint32_t *)&_out->opspecific;
+      *out_id = htonl(domain->id);
+  });
+
+  return 0;
+}
+
+static int domainGetInfo (virDomainPtr domain,
+                          virDomainInfoPtr info)
+{
+  if (!info || !domain) return -1;
+
+  create_nova_request(domain->conn, NOVA_GET_VM_INFO, -1, {
+    memcpy(&_out->opspecific, domain->uuid, VIR_UUID_BUFLEN);
+  });
+
+  uint32_t * memory = (uint32_t *)&_in->opspecific;
+  uint32_t * vcpus  = (uint32_t *)(&_in->opspecific + sizeof(uint32_t));
+  uint64_t * t_cpu  = (uint64_t *)(&_in->opspecific + 2*sizeof(uint32_t));
+
+  if (domain->id == -1)
+    info->state  = VIR_DOMAIN_NOSTATE;
+  else
+    info->state  = VIR_DOMAIN_RUNNING;
+
+  info->maxMem    = ntohl(*memory);  // the maximum memory in KBytes allowed
+  info->memory    = ntohl(*memory);  // the memory in KBytes used by the domain
+  info->nrVirtCpu = ntohl(*vcpus);   // the number of virtual CPUs for the domain
+  info->cpuTime   = be64toh(*t_cpu) * 1000; // get in microseconds - time used in nanoseconds
+
+  return 0;
+}
+
+static int domainGetState(virDomainPtr dom, int *state, int *reason, unsigned int flags ATTRIBUTE_UNUSED)
+{
+  virDomainInfo info;
+  if (!state) return -1;
+  if (-1 == domainGetInfo(dom, &info)) return -1;
+
+  *state = info.state;
+  if (reason) *reason = 0;
+
+  return 0;
+}
+
+static virDriver novaDriver = {
+    .no = VIR_DRV_NOVA,
+    .name = "NOVA",
+    .open = novaOpen, /* 0.8.8 */
+    .close = novaClose, /* 0.8.8 */
+    .nodeGetInfo = nodeGetInfo, /* 0.8.0 */
+    .getCapabilities = getCapabilities, /* 0.9.2 */
+    .listDomains = listDomains, /* 0.8.8 */
+    .numOfDomains = numOfDomains, /* 0.8.8 */
+    .domainCreateXML = domainCreateXML, /* 0.9.2 */
+    .domainLookupByID = domainLookupByID, /* 0.8.8 */
+    .domainLookupByUUID = domainLookupByUUID, /* 0.8.8 */
+    .domainLookupByName = domainLookupByName, /* 0.8.8 */
+    .domainDestroy = domainDestroy, /* 0.8.8 */
+    .domainGetInfo = domainGetInfo, /* 0.8.8 */
+    .domainGetState = domainGetState, /* 0.9.2 */
+    .listDefinedDomains = listDefinedDomains, /* 0.8.8 */
+    .numOfDefinedDomains = numOfDefinedDomains, /* 0.8.8 */
+    .domainCreate = domainCreate, /* 0.8.8 */
+    .domainIsPersistent = domainIsPersistent, /* 0.8.8 */
+    .domainEventRegisterAny = domainEventRegisterAny, /* 0.8.8 */
+    .domainEventDeregisterAny = domainEventDeregisterAny, /* 0.8.8 */
+};
+
+/**
+ * NOVA Register:
+ *
+ * Registers the NOVA driver
+ */
+int
+novaRegister(void)
+{
+    if (virRegisterDriver(&novaDriver) < 0) return -1;
+    return 0;
+}
diff -urN libvirt-0.9.6/src/nova/nova_driver.h libvirt-0.9.6-own/src/nova/nova_driver.h
--- libvirt-0.9.6/src/nova/nova_driver.h	1970-01-01 01:00:00.000000000 +0100
+++ libvirt-0.9.6-own/src/nova/nova_driver.h	2011-10-12 10:12:02.000000000 +0200
@@ -0,0 +1,8 @@
+#ifndef __VIR_NOVA_INTERNAL_H__
+# define __VIR_NOVA_INTERNAL_H__
+
+# include "internal.h"
+
+int novaRegister(void);
+
+#endif /* __VIR_NOVA_INTERNAL_H__ */
diff -urN libvirt-0.9.6/src/nova/nova_types.h libvirt-0.9.6-own/src/nova/nova_types.h
--- libvirt-0.9.6/src/nova/nova_types.h	1970-01-01 01:00:00.000000000 +0100
+++ libvirt-0.9.6-own/src/nova/nova_types.h	2011-10-12 10:12:02.000000000 +0200
@@ -0,0 +1,37 @@
+enum LIBVIRT_NOVA_OPCODE {
+  NOVA_OP_FAILED   = 0x8,
+  NOVA_OP_SUCCEEDED = 0x9,
+  NOVA_PACKET_LEN  = 0x40,
+  NOVA_NUM_OF_ACTIVE_DOMAINS = 0x20,
+  NOVA_NUM_OF_DEFINED_DOMAINS,
+  NOVA_LIST_ACTIVE_DOMAINS,
+  NOVA_LIST_DEFINED_DOMAINS,
+  NOVA_GET_NAME_ID,
+  NOVA_GET_NAME_UUID,
+  NOVA_GET_NAME,
+  NOVA_GET_VM_INFO,
+  NOVA_VM_START,
+  NOVA_VM_DESTROY,
+  NOVA_UNSUPPORTED_VERSION,
+  NOVA_ENABLE_EVENT,
+  NOVA_DISABLE_EVENT,
+  NOVA_EVENT,
+  NOVA_HW_INFO,
+  EVENT_REBOOT = 0xbbbb,
+  EVENT_UNSERVED_IOACCESS = 0xbbc0,
+  EVENT_DMAR_ACCESS = 0xbbd0,
+  EVENT_VDEV_HONEYPOT = 0xbbd1,
+};
+
+struct incoming_packet {
+  uint16_t version;
+  uint16_t opcode;
+  unsigned char opspecific;
+} __attribute__((packed));
+
+struct outgoing_packet {
+  uint16_t version;
+  uint16_t opcode;
+  uint8_t  result;
+  unsigned char opspecific;
+} __attribute__((packed));
