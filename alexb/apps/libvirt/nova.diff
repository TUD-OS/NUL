--- libvirt-0.9.6/configure.ac	2011-09-22 08:42:11.000000000 +0200
+++ libvirt-0.9.6-own/configure.ac	2011-10-27 12:07:49.000000000 +0200
@@ -309,6 +309,8 @@
   AC_HELP_STRING([--with-remote], [add remote driver support @<:@default=yes@:>@]),[],[with_remote=yes])
 AC_ARG_WITH([libvirtd],
   AC_HELP_STRING([--with-libvirtd], [add libvirtd support @<:@default=yes@:>@]),[],[with_libvirtd=yes])
+AC_ARG_WITH([nova],
+  AC_HELP_STRING([--with-nova], [add Nova support @<:@default=check@:>@]),[],[with_nova=yes])
 
 dnl
 dnl in case someone want to build static binaries
@@ -494,6 +496,11 @@
 fi
 AM_CONDITIONAL([WITH_TEST], [test "$with_test" = "yes"])
 
+if test "$with_nova" = "yes" ; then
+    AC_DEFINE_UNQUOTED([WITH_NOVA], 1, [whether NOVA driver is enabled])
+fi
+AM_CONDITIONAL([WITH_NOVA], [test "$with_nova" = "yes"])
+
 if test "$with_remote" = "yes" ; then
     AC_DEFINE_UNQUOTED([WITH_REMOTE], 1, [whether Remote driver is enabled])
 fi
@@ -2511,6 +2518,7 @@
 AC_MSG_NOTICE([     LXC: $with_lxc])
 AC_MSG_NOTICE([    PHYP: $with_phyp])
 AC_MSG_NOTICE([     ESX: $with_esx])
+AC_MSG_NOTICE([    NOVA: $with_nova])
 AC_MSG_NOTICE([ Hyper-V: $with_hyperv])
 AC_MSG_NOTICE([    Test: $with_test])
 AC_MSG_NOTICE([  Remote: $with_remote])
--- libvirt-0.9.6/src/Makefile.am	2011-09-20 05:18:54.000000000 +0200
+++ libvirt-0.9.6-own/src/Makefile.am	2011-10-27 12:07:49.000000000 +0200
@@ -310,6 +310,9 @@
 		lxc/lxc_controller.c				\
 		lxc/veth.c lxc/veth.h
 
+NOVA_DRIVER_SOURCES =						\
+		nova/nova_driver.c nova/nova_driver.h
+
 SECURITY_DRIVER_APPARMOR_HELPER_SOURCES =			\
 		security/virt-aa-helper.c
 
@@ -596,6 +599,21 @@
 libvirt_driver_test_la_SOURCES = $(TEST_DRIVER_SOURCES)
 endif
 
+if WITH_NOVA
+if WITH_DRIVER_MODULES
+mod_LTLIBRARIES += libvirt_driver_nova.la
+else
+noinst_LTLIBRARIES += libvirt_driver_nova.la
+libvirt_la_BUILT_LIBADD += libvirt_driver_nova.la
+endif
+libvirt_driver_nova_la_CFLAGS = \
+		-I@top_srcdir@/src/conf $(AM_CFLAGS)
+if WITH_DRIVER_MODULES
+libvirt_driver_nova_la_LDFLAGS = -module -avoid-version $(AM_LDFLAGS)
+endif
+libvirt_driver_nova_la_SOURCES = $(NOVA_DRIVER_SOURCES)
+endif
+
 if WITH_REMOTE
 if WITH_DRIVER_MODULES
 mod_LTLIBRARIES += libvirt_driver_remote.la
@@ -1084,6 +1102,7 @@
 		$(LIBXL_DRIVER_SOURCES)			\
 		$(ESX_DRIVER_SOURCES)				\
 		$(ESX_DRIVER_EXTRA_DIST)			\
+ 		$(NOVA_DRIVER_SOURCES)				\
 		$(HYPERV_DRIVER_SOURCES)			\
 		$(HYPERV_DRIVER_EXTRA_DIST)			\
 		$(NETWORK_DRIVER_SOURCES)			\
@@ -1483,6 +1502,10 @@
 	$(MKDIR_P) "$(DESTDIR)$(localstatedir)/run/libvirt/libxl"
 	$(MKDIR_P) "$(DESTDIR)$(localstatedir)/log/libvirt/libxl"
 endif
+if WITH_NOVA
+	$(MKDIR_P) "$(DESTDIR)$(localstatedir)/lib/libvirt/nova"
+	$(MKDIR_P) "$(DESTDIR)$(localstatedir)/run/libvirt/nova"
+endif
 if WITH_UML
 	$(MKDIR_P) "$(DESTDIR)$(localstatedir)/lib/libvirt/uml"
 	$(MKDIR_P) "$(DESTDIR)$(localstatedir)/run/libvirt/uml"
@@ -1528,6 +1551,10 @@
 	rmdir "$(DESTDIR)$(localstatedir)/run/libvirt/libxl" ||:
 	rmdir "$(DESTDIR)$(localstatedir)/log/libvirt/libxl" ||:
 endif
+if WITH_NOVA
+	rmdir "$(DESTDIR)$(localstatedir)/lib/libvirt/nova" ||:
+	rmdir "$(DESTDIR)$(localstatedir)/run/libvirt/nova" ||:
+endif
 if WITH_UML
 	rmdir "$(DESTDIR)$(localstatedir)/lib/libvirt/uml" ||:
 	rmdir "$(DESTDIR)$(localstatedir)/run/libvirt/uml" ||:
--- libvirt-0.9.6/src/driver.h	2011-09-16 15:09:43.000000000 +0200
+++ libvirt-0.9.6-own/src/driver.h	2011-10-27 12:07:49.000000000 +0200
@@ -30,6 +30,7 @@
     VIR_DRV_VMWARE = 13,
     VIR_DRV_LIBXL = 14,
     VIR_DRV_HYPERV = 15,
+    VIR_DRV_NOVA
 } virDrvNo;
 
 
--- libvirt-0.9.6/src/libvirt.c	2011-09-22 05:37:44.000000000 +0200
+++ libvirt-0.9.6-own/src/libvirt.c	2011-10-27 12:07:49.000000000 +0200
@@ -73,6 +73,9 @@
 # ifdef WITH_XENAPI
 #  include "xenapi/xenapi_driver.h"
 # endif
+# ifdef WITH_NOVA
+#  include "nova/nova_driver.h"
+# endif
 #endif
 
 #define VIR_FROM_THIS VIR_FROM_NONE
@@ -417,7 +420,9 @@
 
     virLogSetFromEnv();
 
+#if WITH_REMOTE
     virNetTLSInit();
+#endif
 
     VIR_DEBUG("register drivers");
 
@@ -462,6 +467,9 @@
 # ifdef WITH_XENAPI
     virDriverLoadModule("xenapi");
 # endif
+# ifdef WITH_NOVA
+    virDriverLoadModule("nova");
+#endif
 # ifdef WITH_REMOTE
     virDriverLoadModule("remote");
 # endif
@@ -493,6 +501,9 @@
 # ifdef WITH_XENAPI
     if (xenapiRegister() == -1) return -1;
 # endif
+# ifdef WITH_NOVA
+    if (novaRegister () == -1) return -1;
+# endif
 # ifdef WITH_REMOTE
     if (remoteRegister () == -1) return -1;
 # endif
--- libvirt-0.9.6/src/conf/domain_event.c	2011-08-25 11:43:44.000000000 +0200
+++ libvirt-0.9.6-own/src/conf/domain_event.c	2011-10-27 12:07:49.000000000 +0200
@@ -366,6 +366,7 @@
     for (i = 0 ; i < cbList->count ; i++) {
         if (cbList->callbacks[i]->cb == VIR_DOMAIN_EVENT_CALLBACK(callback) &&
             cbList->callbacks[i]->eventID == VIR_DOMAIN_EVENT_ID_LIFECYCLE &&
+            (!cbList->callbacks[i]->dom || !dom || memcmp(dom->uuid, cbList->callbacks[i]->dom->uuid, VIR_UUID_BUFLEN) == 0) &&
             cbList->callbacks[i]->conn == conn) {
             eventReportError(VIR_ERR_INTERNAL_ERROR, "%s",
                              _("event callback already tracked"));
--- libvirt-0.9.6/src/conf/domain_conf.c	2011-09-22 08:37:59.000000000 +0200
+++ libvirt-0.9.6-own/src/conf/domain_conf.c	2011-10-27 12:07:49.000000000 +0200
@@ -86,7 +86,8 @@
               "hyperv",
               "vbox",
               "one",
-              "phyp")
+              "phyp",
+              "nova")
 
 VIR_ENUM_IMPL(virDomainBoot, VIR_DOMAIN_BOOT_LAST,
               "fd",
--- libvirt-0.9.6/src/conf/domain_conf.h	2011-09-06 10:34:44.000000000 +0200
+++ libvirt-0.9.6-own/src/conf/domain_conf.h	2011-10-27 12:07:49.000000000 +0200
@@ -59,6 +59,7 @@
     VIR_DOMAIN_VIRT_VBOX,
     VIR_DOMAIN_VIRT_ONE,
     VIR_DOMAIN_VIRT_PHYP,
+    VIR_DOMAIN_VIRT_NOVA,
 
     VIR_DOMAIN_VIRT_LAST,
 };
--- libvirt-0.9.6/examples/domain-events/events-c/event-test.c	2011-09-03 02:26:55.000000000 +0200
+++ libvirt-0.9.6-own/examples/domain-events/events-c/event-test.c	2011-10-27 12:07:49.000000000 +0200
@@ -162,9 +162,9 @@
                                   int detail,
                                   void *opaque ATTRIBUTE_UNUSED)
 {
-    printf("%s EVENT: Domain %s(%d) %s %s\n", __func__, virDomainGetName(dom),
+    printf("%s EVENT: Domain %s(%d) %s %s detail=%x\n", __func__, virDomainGetName(dom),
            virDomainGetID(dom), eventToString(event),
-           eventDetailToString(event, detail));
+           eventDetailToString(event, detail), detail);
     return 0;
 }
 
@@ -383,7 +383,7 @@
                                                     VIR_DOMAIN_EVENT_CALLBACK(myDomainEventControlErrorCallback),
                                                     strdup("callback control error"), myFreeFunc);
 
-    if ((callback1ret != -1) &&
+    if (//(callback1ret != -1) &&
         (callback2ret != -1) &&
         (callback3ret != -1) &&
         (callback4ret != -1) &&
diff -urN libvirt-0.9.6/src/nova/nova_conf.h libvirt-0.9.6-own/src/nova/nova_conf.h
--- libvirt-0.9.6/src/nova/nova_conf.h	1970-01-01 01:00:00.000000000 +0100
+++ libvirt-0.9.6-own/src/nova/nova_conf.h	2011-10-27 12:07:49.000000000 +0200
@@ -0,0 +1,24 @@
+#ifndef __VIR_NOVA_CONF_H__
+# define __VIR_NOVA_CONF_H__
+
+#include <gnutls/gnutls.h>
+#include <gnutls/x509.h>
+
+#include "domain_event.h"
+
+struct nova_conn {
+  int socket_cmd;
+  int socket_event;
+  virDomainEventCallbackListPtr domainEventCallbacks;
+//  virDomainEventQueuePtr domainEventQueue;
+  virThreadPtr eventthread;
+  bool lock_init;
+  virMutex lock;
+  bool tls;
+  gnutls_session_t session_cmd;
+  gnutls_session_t session_event;
+  gnutls_certificate_credentials_t xcred_cmd;
+  gnutls_certificate_credentials_t xcred_event;
+};
+
+#endif /* __VIR_NOVA_CONF_H__ */
diff -urN libvirt-0.9.6/src/nova/nova_driver.c libvirt-0.9.6-own/src/nova/nova_driver.c
--- libvirt-0.9.6/src/nova/nova_driver.c	1970-01-01 01:00:00.000000000 +0100
+++ libvirt-0.9.6-own/src/nova/nova_driver.c	2011-10-27 14:38:04.000000000 +0200
@@ -0,0 +1,696 @@
+#include <sys/socket.h> //socket
+#include <arpa/inet.h> //inet_pton
+
+#include "virterror_internal.h"
+#include "datatypes.h"
+#include "nova_driver.h"
+#include "buf.h"
+#include "util.h"
+#include "uuid.h"
+#include "capabilities.h"
+#include "memory.h"
+#include "network_conf.h"
+#include "interface_conf.h"
+#include "domain_conf.h"
+#include "domain_event.h"
+#include "event.h"
+#include "storage_conf.h"
+#include "node_device_conf.h"
+#include "xml.h"
+#include "threads.h"
+#include "logging.h"
+
+#include "nova_types.h"
+#include "nova_conf.h"
+
+#include <fcntl.h>
+
+#include <assert.h>
+
+static void novaReadEvents(void *data) {
+  virConnectPtr nconn = (virConnectPtr)data;
+  struct nova_conn * conn = (struct nova_conn *)nconn->privateData;
+
+  unsigned char buf[NOVA_PACKET_LEN];
+  int res;
+
+  while(true) {
+    unsigned count = 0;
+    while(count < sizeof(buf)) {
+      if (conn->tls)
+        res = gnutls_record_recv(conn->session_event, buf + count, sizeof(buf) - count);
+      else
+        res = read(conn->socket_event, buf + count, sizeof(buf) - count);
+      if (res < 0) { printf("eventthread - exiting\n"); return; }
+      count += res;
+    }
+
+    struct outgoing_packet * in = (struct outgoing_packet *)buf;
+
+    if (in->version != ntohs(0xafff)) { printf("eventthread - version error %x != %x\n", ntohs(in->version), 0xafff); continue;}
+    if (in->opcode != ntohs(NOVA_EVENT)) { printf("eventthread - opcode error %x != %x\n", ntohs(in->opcode), NOVA_EVENT ); continue;}
+
+    uint32_t eventid      = *((uint32_t *)(&in->opspecific + 16));
+    uint32_t extra_len    = *((uint32_t *)(&in->opspecific + 16 + sizeof(uint32_t)));
+    unsigned char * extra = &in->opspecific + 16 + 2 * sizeof(uint32_t);
+    virDomainEventPtr event;
+
+    virDomainPtr dom = virDomainLookupByUUID(nconn, &in->opspecific);
+    if (dom) {
+      printf("got event %x %x\n", eventid, ntohl(eventid));
+      if (ntohl(eventid) == EVENT_REBOOT)
+        event = virDomainEventRebootNewFromDom(dom);
+      else
+        event = virDomainEventNewFromDom(dom, ntohl(eventid), ntohl(extra_len) == sizeof(uint32_t) ? *((uint32_t *)extra) : 0);
+    } else {
+      event = virDomainEventNew(-2, "hw", &in->opspecific, ntohl(eventid),
+        ntohl(extra_len) == sizeof(uint32_t) ? *((uint32_t *)extra) : 0);
+      printf("got hw event %p %x\n", event, ntohl(eventid));
+    }
+
+    if (!event) goto cleanup;
+//    if (virDomainEventQueuePush(conn->domainEventQueue, event) < 0) { virDomainEventFree(event); continue; }
+//    virDomainEventQueueDispatch(conn->domainEventQueue, conn->domainEventCallbacks, virDomainEventDispatchDefaultFunc, NULL);
+    virDomainEventDispatch(event, conn->domainEventCallbacks, virDomainEventDispatchDefaultFunc, NULL);
+
+    virDomainEventFree(event);
+
+    cleanup:
+    if (dom) virUnrefDomain(dom);
+  } 
+
+  return; 
+}
+
+/* verify peer's certificate */
+static int tls_verify_cert_cb(gnutls_session_t session)
+{
+  int err, i;
+  unsigned int status, cert_list_size;
+  gnutls_x509_crt_t cert;
+  const gnutls_datum_t *cert_list;
+
+ // This verification function uses the trusted CAs in the credentials structure
+  err = gnutls_certificate_verify_peers2 (session, &status);
+  if (err < 0) {
+    gnutls_perror (err);
+    return err;
+  }
+
+  if (status) {
+    if (status & GNUTLS_CERT_INVALID)
+      printf ("The certificate is not trusted.\n");
+    if (status & GNUTLS_CERT_SIGNER_NOT_FOUND)
+      printf ("The certificate hasn't got a known issuer.\n");
+    if (status & GNUTLS_CERT_REVOKED)
+      printf ("The certificate has been revoked.\n");
+    if (status & GNUTLS_CERT_EXPIRED)
+      printf ("The certificate has expired\n");
+    if (status & GNUTLS_CERT_NOT_ACTIVATED)
+      printf ("The certificate is not yet activated\n");
+    return GNUTLS_E_CERTIFICATE_ERROR;
+  }
+
+  if (gnutls_certificate_type_get (session) != GNUTLS_CRT_X509) return GNUTLS_E_CERTIFICATE_ERROR;
+  if (gnutls_x509_crt_init (&cert) < 0) return GNUTLS_E_CERTIFICATE_ERROR;
+
+  cert_list = gnutls_certificate_get_peers (session, &cert_list_size);
+  if (cert_list == NULL || cert_list_size == 0) return GNUTLS_E_CERTIFICATE_ERROR;
+
+  //XXX check all certificates against trusted CAs list
+  if (gnutls_x509_crt_import (cert, &cert_list[0], GNUTLS_X509_FMT_DER) < 0)
+  {
+    printf ("error parsing certificate\n");
+    return GNUTLS_E_CERTIFICATE_ERROR;
+  }
+
+  struct nova_conn *nconn = gnutls_session_get_ptr (session);
+  if (!nconn) return GNUTLS_E_CERTIFICATE_ERROR;
+
+  char buffer[256];
+  size_t buffer_size;
+  int res = 0;
+  for (i = 0; res >= 0; i++) {
+    buffer_size = sizeof (buffer);
+    res = gnutls_x509_crt_get_subject_alt_name (cert, i, buffer, &buffer_size, NULL);
+
+    if (res == GNUTLS_SAN_IPADDRESS) {
+      struct sockaddr_in addr;
+      bool bchecked = false;
+      //printf("found %s %zd\n", res == GNUTLS_SAN_DNSNAME ? "DNS" : "IPADDRESS", buffer_size);
+      if (buffer_size != 4) return GNUTLS_E_CERTIFICATE_ERROR;
+      //memcpy(&addr.sin_addr, buffer, 4);
+      //printf("remote ip address %s\n", inet_ntoa(addr.sin_addr));
+
+      if (nconn->socket_cmd) {
+        socklen_t addrlen = sizeof(addr);
+        memset(&addr, 0, sizeof(addr));
+        res = getpeername(nconn->socket_cmd, (struct sockaddr *)&addr, &addrlen);
+        if (memcmp(buffer, &addr.sin_addr, 4)) {
+          struct in_addr * tmp = (struct in_addr *)buffer;
+          printf("IP address in certificate doesn't match ip address of connection (cmd) '%s' !=",
+                 inet_ntoa(*tmp));
+          printf("'%s'\n", inet_ntoa(addr.sin_addr));
+          return GNUTLS_E_CERTIFICATE_ERROR;
+        }
+        bchecked = true;
+      }
+      if (nconn->socket_event) {
+        socklen_t addrlen = sizeof(addr);
+        memset(&addr, 0, sizeof(addr));
+        res = getpeername(nconn->socket_event, (struct sockaddr *)&addr, &addrlen);
+        if (memcmp(buffer, &addr.sin_addr, 4)) {
+          struct in_addr * tmp = (struct in_addr *)buffer;
+          printf("IP address in certificate doesn't match ip address of connection (event) '%s' !=",
+                 inet_ntoa(*tmp));
+          printf("'%s'\n", inet_ntoa(addr.sin_addr));
+          return GNUTLS_E_CERTIFICATE_ERROR;
+        }
+        bchecked = true;
+      }
+      if (!bchecked)
+        return GNUTLS_E_CERTIFICATE_ERROR;
+    }
+    if (res == GNUTLS_SAN_DNSNAME) {
+      printf("GNUTLS_SAN_DNSNAME check not supported, abort\n");
+      return GNUTLS_E_CERTIFICATE_ERROR;
+    }
+  }
+//  const char * host;
+//  if (!host || !gnutls_x509_crt_check_hostname (cert, host))
+//  {
+//    printf ("The certificate's owner does not match hostname '%s'\n", host ? host : "unknown");
+//    printf ("result %d\n", gnutls_x509_crt_check_hostname (cert, "some.name.com"));
+//    return GNUTLS_E_CERTIFICATE_ERROR;
+//  }
+
+
+  gnutls_x509_crt_deinit (cert);
+
+  return 0; //all ok, continue
+
+}
+
+static virDrvOpenStatus novaOpen(virConnectPtr conn,
+                    virConnectAuthPtr auth ATTRIBUTE_UNUSED,
+                    unsigned int flags ATTRIBUTE_UNUSED)
+{
+    int rc, i;
+    struct nova_conn *nconn = 0;
+    bool btls = false;
+    struct {
+      int * socket;
+      int port;
+      gnutls_session_t *session;
+      gnutls_certificate_credentials_t * xcred;
+    } connections [2];
+
+    if (!conn || !conn->uri || !conn->uri->scheme) return VIR_DRV_OPEN_DECLINED;
+
+    if (STREQ(conn->uri->scheme, "nova+tls")) btls = true;
+    if (!btls && STRNEQ(conn->uri->scheme, "nova"))
+      return VIR_DRV_OPEN_DECLINED;
+
+    if (!conn->uri->server || !conn->uri->port || conn->privateData)
+        return VIR_DRV_OPEN_DECLINED;
+
+    if (VIR_ALLOC(nconn) < 0) goto error_socket;
+    memset(nconn, 0, sizeof(*nconn));
+    nconn->tls = btls;
+
+    connections[0].socket  = &nconn->socket_cmd;
+    connections[0].port    = conn->uri->port;
+    connections[0].session = &nconn->session_cmd;
+    connections[0].xcred   = &nconn->xcred_cmd;
+    connections[1].socket  = &nconn->socket_event;
+    connections[1].port    = conn->uri->port + 1;
+    connections[1].session = &nconn->session_event;
+    connections[1].xcred   = &nconn->xcred_event;
+
+    for (i=0; i < 2; i++) {
+      struct sockaddr_in addr;
+      addr.sin_family = AF_INET;
+      addr.sin_port = htons(connections[i].port);
+      if (1 != inet_pton(AF_INET, conn->uri->server, &addr.sin_addr)) goto error_socket;
+
+      *connections[i].socket = socket(AF_INET, SOCK_STREAM, 0);
+      if (*connections[i].socket < 0) goto error;
+      if (connect(*connections[i].socket, (struct sockaddr *)&addr, sizeof(addr))) goto error_socket;
+
+      // TLS with x509 - start
+      if (btls) {
+        if (gnutls_global_init() != GNUTLS_E_SUCCESS) goto error_socket;
+        if (gnutls_init(connections[i].session, GNUTLS_CLIENT) != GNUTLS_E_SUCCESS) goto error_socket;
+
+        /* X509 stuff */
+        if (gnutls_certificate_allocate_credentials(connections[i].xcred) != GNUTLS_E_SUCCESS) goto error_tls_init;
+        /* sets the trusted cas file */
+        //XXX make file name via xml configurable
+
+        if (gnutls_certificate_set_x509_trust_file(*connections[i].xcred, "cacert.pem", GNUTLS_X509_FMT_PEM) <= 0) goto error_tls_cert;
+        gnutls_certificate_set_verify_function(*connections[i].xcred, tls_verify_cert_cb);
+        gnutls_certificate_set_verify_flags(*connections[i].xcred, GNUTLS_VERIFY_ALLOW_X509_V1_CA_CRT);
+
+        if (gnutls_priority_set_direct(*connections[i].session, "PERFORMANCE", NULL) != GNUTLS_E_SUCCESS) goto error_tls_cert;
+        if (gnutls_credentials_set(*connections[i].session, GNUTLS_CRD_CERTIFICATE, *connections[i].xcred) != GNUTLS_E_SUCCESS) goto error_tls_cert;
+
+        gnutls_transport_set_ptr (*connections[i].session, (gnutls_transport_ptr_t) *connections[i].socket);
+        gnutls_session_set_ptr (*connections[i].session, nconn);
+
+        if ((rc = gnutls_handshake (*connections[i].session)) < 0) {
+          gnutls_perror (rc);
+          printf("error handshake %d %d\n", *connections[0].socket, *connections[1].socket);
+          if (rc == GNUTLS_E_FATAL_ALERT_RECEIVED || rc == GNUTLS_E_WARNING_ALERT_RECEIVED) {
+            gnutls_alert_description_t alert = gnutls_alert_get(*connections[i].session);
+            printf("%s alert: (%d) %s\n", rc == GNUTLS_E_WARNING_ALERT_RECEIVED ? "warning" : "fatal", alert, gnutls_alert_get_name(alert));
+          }
+          goto error;
+        }
+      }
+      // TLS - end
+    }
+
+    if (VIR_ALLOC(nconn->domainEventCallbacks) < 0) goto error;
+//    if (!(nconn->domainEventQueue = virDomainEventQueueNew())) goto error;
+
+    conn->privateData = nconn;
+
+    if (VIR_ALLOC(nconn->eventthread) < 0) goto error; 
+    if (virMutexInit(&nconn->lock) < 0) goto error;
+    else nconn->lock_init = true;
+    if (virThreadCreate(nconn->eventthread, true, novaReadEvents, conn)) goto error;
+
+    return VIR_DRV_OPEN_SUCCESS;
+
+    /* error handling */
+    error:
+    if (btls) {
+      gnutls_bye(nconn->session_cmd, GNUTLS_SHUT_WR);
+      if (i > 0) gnutls_bye(nconn->session_event, GNUTLS_SHUT_WR);
+    }
+
+    error_tls_cert:
+    if (btls) {
+      gnutls_certificate_free_credentials (nconn->xcred_cmd);
+      if (i > 0) gnutls_certificate_free_credentials (nconn->xcred_event);
+    }
+
+    error_tls_init:
+    if (btls) {
+      gnutls_deinit (nconn->session_cmd);
+      if (i > 0) gnutls_deinit (nconn->session_event);
+    }
+
+    error_socket:
+    if (nconn && nconn->domainEventCallbacks) VIR_FREE(nconn->domainEventCallbacks);
+    if (nconn && nconn->eventthread) VIR_FREE(nconn->eventthread);
+    if (nconn && nconn->lock_init) virMutexDestroy(&nconn->lock);
+    if (*connections[0].socket) close(*connections[0].socket);
+    if (*connections[1].socket) close(*connections[1].socket);
+    if (nconn) VIR_FREE(nconn);
+
+    return VIR_DRV_OPEN_DECLINED;
+}
+
+static int novaClose(virConnectPtr conn)
+{
+    int res;
+    struct nova_conn *nconn;
+
+    if (!(nconn = conn->privateData)) return -1;
+    
+    if (nconn->tls) {
+      gnutls_bye(nconn->session_cmd, GNUTLS_SHUT_WR);
+      gnutls_bye(nconn->session_event, GNUTLS_SHUT_WR);
+      gnutls_certificate_free_credentials (nconn->xcred_cmd);
+      gnutls_certificate_free_credentials (nconn->xcred_event);
+      gnutls_deinit (nconn->session_cmd);
+      gnutls_deinit (nconn->session_event);
+    }
+
+    if (nconn->domainEventCallbacks) VIR_FREE(nconn->domainEventCallbacks);
+//    if (nconn->domainEventQueue) virDomainEventQueueFree(nconn->domainEventQueue);
+    if (nconn->eventthread) {
+      virThreadJoin(nconn->eventthread);
+      VIR_FREE(nconn->eventthread);
+    }
+
+    res = close(nconn->socket_cmd);
+    printf("nova - %s - closing mgmt connection ...\n", res ? "failure" : "success");
+    res = close(nconn->socket_event);
+    printf("nova - %s - closing event connection ...\n", res ? "failure" : "success");
+
+
+    if (nconn->lock_init) virMutexDestroy(&nconn->lock);
+    memset(nconn, 0, sizeof(*nconn));
+    VIR_FREE(nconn);
+    conn->privateData = 0;
+
+    return res;
+}
+
+#define create_nova_request(CONN, NOVAOPCODE, ERRORCODE, CODE) \
+  struct nova_conn *nconn = (CONN)->privateData; \
+  unsigned char buf[NOVA_PACKET_LEN]; \
+  struct incoming_packet * _out = (struct incoming_packet *)buf; \
+  ssize_t res_nova_request; \
+\
+  _out->version = htons(0xafff); \
+  _out->opcode  = htons(NOVAOPCODE); \
+\
+  CODE \
+\
+  virMutexLock(&nconn->lock); \
+  unsigned count_nova_request = 0; \
+  if (nconn->tls) { \
+    if (sizeof(buf) != gnutls_record_send(nconn->session_cmd, buf, sizeof(buf))) { res_nova_request = -1; goto request_abort; } \
+  } else { \
+    if (sizeof(buf) != write(nconn->socket_cmd, buf, sizeof(buf))) { res_nova_request = -1; goto request_abort; } \
+  } \
+  while(count_nova_request < sizeof(buf)) { \
+    if (nconn->tls) { \
+      res_nova_request = gnutls_record_recv(nconn->session_cmd, buf + count_nova_request, sizeof(buf) - count_nova_request); \
+    } else { \
+      res_nova_request = read(nconn->socket_cmd, buf + count_nova_request, sizeof(buf) - count_nova_request); \
+    } \
+    if (res_nova_request < 0) goto request_abort; \
+    count_nova_request += res_nova_request; \
+  } \
+  request_abort: \
+  virMutexUnlock(&nconn->lock); \
+  if (res_nova_request < 0) return ERRORCODE; \
+\
+  struct outgoing_packet * _in = (struct outgoing_packet *)buf; \
+\
+  if (_in->version != ntohs(0xafff)) { printf("version error %x\n", ntohs(_in->version)); return ERRORCODE; } \
+  if (_in->opcode != ntohs(NOVAOPCODE)) { printf("opcode error\n"); return ERRORCODE; } \
+  if (_in->result != NOVA_OP_SUCCEEDED) { return ERRORCODE; }
+
+static int nodeGetInfo(virConnectPtr conn, virNodeInfoPtr info) {
+  create_nova_request(conn, NOVA_HW_INFO, -1, {});
+
+  uint32_t * data = (uint32_t *)&_in->opspecific;
+  info->memory = ntohl(*data++); info->cpus = ntohl(*data++);
+  info->mhz = ntohl(*data++); info->nodes = ntohl(*data++);
+  info->sockets = ntohl(*data++); info->cores = ntohl(*data++);
+  info->threads = ntohl(*data++);
+  memcpy(info->model, data, 13);
+  return 0;
+}
+
+static int numOfDomains(virConnectPtr conn) {
+
+  create_nova_request(conn, NOVA_NUM_OF_ACTIVE_DOMAINS, -1, {});
+
+  uint32_t * num = (uint32_t *)&_in->opspecific;
+  uint32_t res = ntohl(*num);
+  return res;
+}
+
+static virDomainPtr domainCreateXML(virConnectPtr conn, const char *xml,
+                                      unsigned int flags)
+{
+  return 0;
+}
+
+static char *getCapabilities(virConnectPtr conn ATTRIBUTE_UNUSED) {
+  const char cap[] = \
+  "<host>" \
+   "<cpu>" \
+     "<arch>i686</arch" \
+   "</cpu>" \
+  "</host>" \
+  "<guest>" \
+   "<os_type>hvm</os_type>" \
+   "<arch name=""i686"">" \
+     "<wordsize>32</wordsize>" \
+   "</arch>" \
+   "<features/>" \
+  "</guest>";
+  char * tmp;
+  if (-1 == virAlloc(&tmp, sizeof(cap))) return 0;
+  else memcpy(tmp, cap, sizeof(cap));
+  return tmp;
+}
+
+static int listDomains (virConnectPtr conn,
+                            int *ids,
+                            int maxids)
+{
+  create_nova_request(conn, NOVA_LIST_ACTIVE_DOMAINS, -1, {});
+
+  unsigned i;
+  uint32_t * _ids  = (uint32_t *)&_in->opspecific;
+  uint32_t _maxids = ntohl(*_ids);
+
+  _ids++;
+
+  uint32_t max = _maxids < maxids ? _maxids : maxids;
+
+  for (i=0; i < max; i++) {
+    *ids = ntohl(*_ids);
+    ids++;
+    _ids++; 
+  }
+
+  return max;
+}
+
+static int numOfDefinedDomains(virConnectPtr conn) {
+  create_nova_request(conn, NOVA_NUM_OF_DEFINED_DOMAINS, -1, {});
+
+  uint32_t * num = (uint32_t *)&_in->opspecific;
+  uint32_t res = ntohl(*num);
+
+  return res;
+}
+
+static virDomainPtr domainLookupByUUID(virConnectPtr conn,
+                                       const unsigned char *uuid)
+{
+  create_nova_request(conn, NOVA_GET_NAME_UUID, NULL, 
+    {
+      memcpy(&_out->opspecific, uuid, VIR_UUID_BUFLEN);
+    });
+
+  buf[NOVA_PACKET_LEN - 1] = 0; //zero terminate for sure
+
+  uint32_t * _op = (uint32_t *)&_in->opspecific;
+  int id = ntohl(*_op);
+  char const * name = (char const *)(&_in->opspecific + sizeof(*_op));
+
+  virDomainPtr res = virGetDomain(conn, name, uuid);
+  if (res) res->id = id;
+
+  return res;
+}
+
+static virDomainPtr domainLookupByID(virConnectPtr conn, int id)
+{
+  create_nova_request(conn, NOVA_GET_NAME_ID, NULL, 
+    {
+      uint32_t * out_id = (uint32_t *)&_out->opspecific;
+      *out_id = htonl(id);
+    });
+
+  buf[NOVA_PACKET_LEN - 1] = 0; //zero terminate for sure
+  unsigned char const * uuid = (unsigned char const *)&_in->opspecific;
+  char const * name = (char const *)(&_in->opspecific + 16);
+
+  virDomainPtr res = virGetDomain(conn, name, uuid);
+  if (res) res->id = id;
+
+  return res;
+}
+
+static int domainCreate(virDomainPtr domain) {
+  create_nova_request(domain->conn, NOVA_VM_START, -1, {
+    unsigned char _uuid[VIR_UUID_BUFLEN];
+    if (-1 == virUUIDGenerate(_uuid)) return -1;
+
+    char * uuid = (char *)&_out->opspecific;
+    memcpy(uuid, domain->uuid, VIR_UUID_BUFLEN);
+    uuid += VIR_UUID_BUFLEN;
+    memcpy(uuid, _uuid, VIR_UUID_BUFLEN);
+  });
+
+  uint32_t * _op = (uint32_t *)&_in->opspecific;
+  int id = ntohl(*_op);
+
+  if (id) {
+    virDomainPtr res = domainLookupByID(domain->conn, id);
+    if (res) res->id = id;
+    else return -1;
+  }
+  return 0;
+}
+
+static int domainIsPersistent(virDomainPtr dom) {
+  if (!dom) return -1;
+
+  if (dom->id == -1) return 1; //XXX fix it - guessing
+  return 0;
+}
+
+static int domainEventRegisterAny(virConnectPtr conn, 
+  virDomainPtr dom, int eventID, virConnectDomainEventGenericCallback cb,
+  void * opaque, virFreeCallback freecb) //XXX currently no registry per event possible, all or nothing for all domains or just for a specific
+{
+  int res;
+
+  create_nova_request(conn, NOVA_ENABLE_EVENT, -1, 
+    {
+      uint32_t * out_id = (uint32_t *)&_out->opspecific;
+      if (dom)
+        *out_id = htonl(dom->id);
+      else
+        *out_id = htonl(-1);
+    });
+
+  res = virDomainEventCallbackListAddID(conn,
+                                        nconn->domainEventCallbacks,
+                                        dom, eventID,
+                                        cb, opaque, freecb);
+  return res;
+}
+
+static int domainEventDeregisterAny(virConnectPtr conn, int callbackID)
+{
+  create_nova_request(conn, NOVA_DISABLE_EVENT, -1,
+    {
+      uint32_t * out_id = (uint32_t *)&_out->opspecific;
+      *out_id = htonl(-1);
+    });
+ 
+  return virDomainEventCallbackListRemoveID(conn, nconn->domainEventCallbacks, callbackID);
+}
+
+static int listDefinedDomains(virConnectPtr conn, char ** const names, int maxnames)
+{
+  unsigned i;
+  char * out;
+
+  create_nova_request(conn, NOVA_LIST_DEFINED_DOMAINS, -1, {
+      uint32_t * max = (uint32_t *)&_out->opspecific;
+      *max = htonl(maxnames);
+    });
+
+  uint32_t * _num = (uint32_t *)&_in->opspecific;
+  uint32_t    num = ntohl(*_num);
+  char     * name = (char *)(&_in->opspecific + 4);
+
+  for (i=0; i < num; i++) {
+    uint32_t len   = strlen(name) + 1;
+  
+    if (-1 == virAlloc(&out, len)) return -1;
+    memcpy(out, name, len);
+    names[i] = out;
+    name += len;
+  }
+
+  return num;
+}
+
+static virDomainPtr domainLookupByName(virConnectPtr conn, const char * name)
+{
+  create_nova_request(conn, NOVA_GET_NAME, NULL,
+    {
+      if (strlen(name) + 1 > NOVA_PACKET_LEN - (&_out->opspecific - buf)) return NULL;
+      memcpy(&_out->opspecific, name, strlen(name) + 1);
+    });
+
+  unsigned char const * uuid = (unsigned char const *)&_in->opspecific;
+  char const * _name = (char const *)(&_in->opspecific + 16);
+
+  if (memcmp(name, _name, strlen(name) + 1)) return NULL;
+  virDomainPtr res = virGetDomain(conn, name, uuid);
+  if (res) res->id = -1;
+
+  return res;
+}
+
+static int domainDestroy (virDomainPtr domain)
+{
+  if (!domain || domain->id == -1) return -1;
+
+  create_nova_request(domain->conn, NOVA_VM_DESTROY, -1, {
+      uint32_t * out_id = (uint32_t *)&_out->opspecific;
+      *out_id = htonl(domain->id);
+  });
+
+  return 0;
+}
+
+static int domainGetInfo (virDomainPtr domain,
+                          virDomainInfoPtr info)
+{
+  if (!info || !domain) return -1;
+
+  create_nova_request(domain->conn, NOVA_GET_VM_INFO, -1, {
+    memcpy(&_out->opspecific, domain->uuid, VIR_UUID_BUFLEN);
+  });
+
+  uint32_t * memory = (uint32_t *)&_in->opspecific;
+  uint32_t * vcpus  = (uint32_t *)(&_in->opspecific + sizeof(uint32_t));
+  uint64_t * t_cpu  = (uint64_t *)(&_in->opspecific + 2*sizeof(uint32_t));
+
+  if (domain->id == -1)
+    info->state  = VIR_DOMAIN_NOSTATE;
+  else
+    info->state  = VIR_DOMAIN_RUNNING;
+
+  info->maxMem    = ntohl(*memory);  // the maximum memory in KBytes allowed
+  info->memory    = ntohl(*memory);  // the memory in KBytes used by the domain
+  info->nrVirtCpu = ntohl(*vcpus);   // the number of virtual CPUs for the domain
+  info->cpuTime   = be64toh(*t_cpu) * 1000; // get in microseconds - time used in nanoseconds
+
+  return 0;
+}
+
+static int domainGetState(virDomainPtr dom, int *state, int *reason, unsigned int flags ATTRIBUTE_UNUSED)
+{
+  virDomainInfo info;
+  if (!state) return -1;
+  if (-1 == domainGetInfo(dom, &info)) return -1;
+
+  *state = info.state;
+  if (reason) *reason = 0;
+
+  return 0;
+}
+
+static virDriver novaDriver = {
+    .no = VIR_DRV_NOVA,
+    .name = "NOVA",
+    .open = novaOpen, /* 0.8.8 */
+    .close = novaClose, /* 0.8.8 */
+    .nodeGetInfo = nodeGetInfo, /* 0.8.0 */
+    .getCapabilities = getCapabilities, /* 0.9.2 */
+    .listDomains = listDomains, /* 0.8.8 */
+    .numOfDomains = numOfDomains, /* 0.8.8 */
+    .domainCreateXML = domainCreateXML, /* 0.9.2 */
+    .domainLookupByID = domainLookupByID, /* 0.8.8 */
+    .domainLookupByUUID = domainLookupByUUID, /* 0.8.8 */
+    .domainLookupByName = domainLookupByName, /* 0.8.8 */
+    .domainDestroy = domainDestroy, /* 0.8.8 */
+    .domainGetInfo = domainGetInfo, /* 0.8.8 */
+    .domainGetState = domainGetState, /* 0.9.2 */
+    .listDefinedDomains = listDefinedDomains, /* 0.8.8 */
+    .numOfDefinedDomains = numOfDefinedDomains, /* 0.8.8 */
+    .domainCreate = domainCreate, /* 0.8.8 */
+    .domainIsPersistent = domainIsPersistent, /* 0.8.8 */
+    .domainEventRegisterAny = domainEventRegisterAny, /* 0.8.8 */
+    .domainEventDeregisterAny = domainEventDeregisterAny, /* 0.8.8 */
+};
+
+/**
+ * NOVA Register:
+ *
+ * Registers the NOVA driver
+ */
+int
+novaRegister(void)
+{
+    if (virRegisterDriver(&novaDriver) < 0) return -1;
+    return 0;
+}
diff -urN libvirt-0.9.6/src/nova/nova_driver.h libvirt-0.9.6-own/src/nova/nova_driver.h
--- libvirt-0.9.6/src/nova/nova_driver.h	1970-01-01 01:00:00.000000000 +0100
+++ libvirt-0.9.6-own/src/nova/nova_driver.h	2011-10-27 12:07:49.000000000 +0200
@@ -0,0 +1,8 @@
+#ifndef __VIR_NOVA_INTERNAL_H__
+# define __VIR_NOVA_INTERNAL_H__
+
+# include "internal.h"
+
+int novaRegister(void);
+
+#endif /* __VIR_NOVA_INTERNAL_H__ */
diff -urN libvirt-0.9.6/src/nova/nova_types.h libvirt-0.9.6-own/src/nova/nova_types.h
--- libvirt-0.9.6/src/nova/nova_types.h	1970-01-01 01:00:00.000000000 +0100
+++ libvirt-0.9.6-own/src/nova/nova_types.h	2011-10-27 12:07:49.000000000 +0200
@@ -0,0 +1,37 @@
+enum LIBVIRT_NOVA_OPCODE {
+  NOVA_OP_FAILED   = 0x8,
+  NOVA_OP_SUCCEEDED = 0x9,
+  NOVA_PACKET_LEN  = 0x40,
+  NOVA_NUM_OF_ACTIVE_DOMAINS = 0x20,
+  NOVA_NUM_OF_DEFINED_DOMAINS,
+  NOVA_LIST_ACTIVE_DOMAINS,
+  NOVA_LIST_DEFINED_DOMAINS,
+  NOVA_GET_NAME_ID,
+  NOVA_GET_NAME_UUID,
+  NOVA_GET_NAME,
+  NOVA_GET_VM_INFO,
+  NOVA_VM_START,
+  NOVA_VM_DESTROY,
+  NOVA_UNSUPPORTED_VERSION,
+  NOVA_ENABLE_EVENT,
+  NOVA_DISABLE_EVENT,
+  NOVA_EVENT,
+  NOVA_HW_INFO,
+  EVENT_REBOOT = 0xbbbb,
+  EVENT_UNSERVED_IOACCESS = 0xbbc0,
+  EVENT_DMAR_ACCESS = 0xbbd0,
+  EVENT_VDEV_HONEYPOT = 0xbbd1,
+};
+
+struct incoming_packet {
+  uint16_t version;
+  uint16_t opcode;
+  unsigned char opspecific;
+} __attribute__((packed));
+
+struct outgoing_packet {
+  uint16_t version;
+  uint16_t opcode;
+  uint8_t  result;
+  unsigned char opspecific;
+} __attribute__((packed));
